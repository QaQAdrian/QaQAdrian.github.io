---
categories:
  - Java
date: "2012-04-06"
description: ""
# slug: 
tags:
  - Algorithm
  - ReadingSummary
categories:
  - ReadingSummary
title: 《剑指Offer》读后总结
draft: true
---

《剑指Offer》不知道这本书是怎样在我的圈子里火起来的，但确实写的很不错，我从头到尾读了一遍，总结一下这本书提到的那些算法和思想，以及面试技巧。《剑指Offer》使用的语言是C++，我主要是用Javascript或Java做算法题。
<!--more-->

# 《剑指Offer》读后总结

## 一、章节总结

### 第二章：基础知识
《剑指Offer》使用的语言是C++，所以在开篇部分的基础知识，主要以C++相关语法知识为主，包含C家族的几个语言。
提到的考察内容：
- 语言基础知识：sizeof （这个类似问题。。。我觉得见过N+1次了，C相关的面试基本都会考），虚函数，指针，单例模式
- 数据结构：数组、链表、字符串（这个也算么）、树、栈和队列
- 常见数据操作：递归与循环、查找和排序、回溯、动态规划与贪婪算法、位运算

## 二、算法题总结

### 1.查找重复数据
这种类型，第一想到的都是哈希表。在Java中是以数组+链表或红黑树实现哈希表并解决哈希冲突的，但是有几种情况是可以选择更优方案。

1. 当数据的类型是 __整型或字符__ 时，我们可以根据题目分析，数组的索引是否可以作为哈希表的Key。

- 面试题3：数组中重复的数字（数组，哈希表）
    ```text
    如果数字范围为0~n-1，数组可以修改的话,
    以数组索引为Key，在原数组上交换位置可以达到时间复杂度O(n)就可以找到重复数字且不需要额外空间
    ```
    进阶问题：长度为n+1，数字都在1～n内，不修改原数组，如何查找重复数字
    ```text
    书中提供的方法是采用二分法。
    先计算1~n/2这个范围的数字，在数组中出现的次数，如果次数不超过n/2，则再统计n/2~n，
    以此循环查找。最终时间复杂度O(nlogn)，没有额外空间。

    我感觉直接使用排序再加上一趟查找也可以。。。
    ```

- 面试题50：第一个只出现一次的字符（数组，哈希表）
  
  使用哈希表需要O(n)空间，但是使用长度为256的数组空间复杂度O(1)

### 2.需要理解循环过程（辅助绘图）
- 面试题4：二维数组中的查找（数组）

    先通过绘制矩阵图，然后分析即可

- 面试题5：替换空格（数组）
    
    计算好替换后的长度，由尾至头进行拷贝和替换空格，可以避免由于一个字符长度变长导致后续所有字符都需要移位的问题
    
    合并数组问题也可以采用由后至前的方式。
- 面试题6：从尾到头打印链表（链表、栈）

    使用栈作为辅助空间
- 面试题7：重建二叉树（二叉树）
    
    题目中提供中序遍历和先序遍历的输出结果，根据先序遍历找到根节点，再在中序遍历中找到这个根节点，确认左右子树
- 面试题8：二叉树的下一个节点（二叉树）
    
    画图分析所有情况
- 面试题9：两个栈实现一个队列（栈、队列）
    
    画图分析，可以得知一个栈作为入队用，另一个栈作为出队用。当出队用的栈未空时，不需要入队用的栈导入数据。

    进阶问题：两个队列实现一个栈

    每次出栈时，都需要交换两个队列的数据。
- 面试题10：斐波那契数列（动态规划）
    缓存前面几步的结果，时间复杂度O(n)，没有额外空间。（数学公式递归O(logn)）
    相似问题：青蛙跳台问题
- 面试题11：旋转数组的最小数字（二分查找、数组）
    
    特殊情况：当头、尾、中间节点值相同时，只能采用顺序查找，如[1,0,1,1,1]

- 面试题12：矩阵中的路径（数组、回溯法）
- 面试题13：机器人的运动范围（数组、回溯法）
- 面试题14：剪绳子（动态规划、贪婪算法）  
    注意缓存的2、3的值，和长度2、3的结果不一致。
- 面试题15：二进制中1的个数（位运算）
    
    考虑符号位，采用无符号右移。特殊解法：
    ```c 
    while(n){
        n = (n - 1) & n;
        count++;
    }
    ```
- 面试题16：数值的整数次方（位运算，动态规划）  
  考虑多种情况：1、指数为负数 2、0和1 3、动态规划以节约时间
- 面试题17：打印从1到最大的N位数（字符串）  
  使用字符串模拟数字，避免溢出问题
- 面试题18：O(1)删除链表的节点（链表）  
  这个问题简直是个文字游戏，题目中已经提供的节点的实例，而不是value之类的值，所以我们可以直接将cur.v = cur.next.v，然后cur.next = cur.next.next这样删除节点。但是要注意的是，当前节点如果是尾节点或者头节点，需要做特殊处理。  
  相似问题：删除链表中的重复节点  
  特殊情况是如果重复的节点是连续出现的。
- 面试题19：正则表达式匹配（我不想看这种题。）
- 面试题20：表示数值的字符串（我也不想看这种题。）
- 面试题21：调整数组顺序使奇数位于偶数前面（双指针）  
  这道题本身并没有要求排序，只要求奇数在偶数前面，所以双指针即可。但是作为秒杀Offer的解法，是把调整位置的判断函数提出来，作为lambda或者匿名函数之类的。
- 面试题22：链表中倒数第K个节点（双指针）  
  一个指针先走K，另一个指针再走，步长都为1
- 面试题23：链表中环的入口点（双指针）  
  需要一点点逻辑推断，或者是数学公式验证。  
  一种快慢指针，步长=2和步长=1，他们相遇（如果存在环）时，一个指针不动，另一个指针步长=1，这样可以计算环中节点数目为K。然后就比较简单了。两个节点回到头节点，一个先走K步，然后一起走，相遇的节点就是入口点。
  其他方式还不如这种简单易懂，可以参考leetcode上面。。。
- 面试题24：反转链表（链表）  
  注意空链表，尾节点断开丢失，缓存反转后头节点指针。
- 面试题25：合并两个排序的链表  
- 面试题26：树的子结构（二叉树遍历）
- 面试题27：二叉树的镜像（二叉树遍历）
- 面试题28：对称的二叉树（二叉树遍历）  
  遍历时考虑空指针，先序遍历和根-右-左（DRL）遍历
- 面试题29：顺时针打印矩阵（数组）
- 面试题30：包含min函数的栈  
  用额外一个栈空间，值为每一步操作对应的最小值  
  类似题目：包含max函数的队列（与min stack相比要麻烦一些）
- 面试题31：栈的压入、弹出序列
- 面试题32：从上到下打印二叉树（二叉树广度遍历）  
  类似题目：广度优先遍历有向图、分行打印二叉树、Z字形打印二叉树
- 面试题33：二叉搜索树的后序遍历序列（二叉树后序遍历）
- 面试题34：二叉树中和为某一值的路径（二叉树先序遍历）
- 面试题35：复杂链表的复制（链表）  
  在原链表上进行拷贝节点，A->A'->B->B'
- 面试题36：二叉搜索树与双向链表（二叉树中序遍历）
- 面试题37：序列化二叉树（二叉树先序遍历）
- 面试题38：字符串的排列（递归）
- 面试题39：数组中出现次数超过一半的数字（二分法）  
  排序：O(nlogn)；二分：O(n)；根据数组特点O(n)
- 面试题40：最小的K个树（二分法、大顶堆）  
  二分：O(n)；大顶堆：O(nlogk)
- 面试题41：数据流中的中位数（）  
  二分法，查找：O(n)，插入：O(1)；  
  排好序的数组：O(1)，O(n)  
  红黑树、大小顶堆：O(1)，O(logn)
- 面试题42：连续子数组的最大和（动态规划、数组）  
  动态规划；数组规律
- 面试题43：1～n中1出现的次数
- 面试题44：数字序列中某一位的数字
- 面试题45：把数组排成最小的数（数组排序）
- 面试题46：把数字翻译成字符串
- 面试题47：礼物的最大价值（动态规划）
- 面试题48：最长不含重复字符的子字符串（动态规划）
- 面试题49：丑数
- 面试题50：第一次只出现一次的字符
- 面试题51：数组中的逆序对
- 面试题52：两个链表的第一个公共节点（链表，栈）
- 面试题53：在排序数组中查找数字（二分、再二分、再再二分）  
  类似题目：0～n-1中缺失的数字；  
  类似题目：数组中数值和下标相等的元素；  
- 面试题54：二叉搜索树的第K大的节点（中序）
- 面试题55：二叉树的深度（二叉树遍历）  
  类似题目：平衡二叉树（后序遍历）
- 面试题56：数组中数字出现的次数（位运算+二分？）  
  类似题目：数组中唯一只出现一次的数字，其余出现3次
- 面试题57：和为S的数字（双指针）  
  类似题目：何为S的连续正数序列
- 面试题58：翻转字符串  
  类似题目：左旋转字符串
- 面试题59：队列的最大值（滑动窗口）  
  类似题目：队列最大值
- 面试题60：n个骰子的点数（递归/循环）
- 面试题61：扑克牌中的顺子
- 面试题62：圆圈中最后剩下的数字
- 面试题63：股票最大利润（贪心？
- 面试题64：1+2..+n
- 面试题65：不用加减乘除做假发
- 面试题66：构建乘积数组
- 面试题67：字符串转数字
- 面试题68：树中两个节点的最低公共祖先
